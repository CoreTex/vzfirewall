#!/usr/bin/perl -w
#
# vzfirewall:  A simple firewall for OpenVZ
#
# See 'vzfirewall -h' for documentaion.
#
# Check https://github.com/DmitryKoterov/vzfirewall
# for latest version and development info.

use strict;
use Pod::Usage;
use File::Basename;
use POSIX 'strftime';
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);

my $VERSION = "1.12, 2014-01-14";
my $CONF;       # vzfirewall configuration file
my $DIR;        # directory with openvz container .conf files

my %opt = ();
my @ICMP_TYPES;
my @FAILSAFE_ADDRS;
GetOptions(\%opt, 'help|h', 'version|V', 'apply|a', 'test|t',
	'force|f', 'dir|d=s', 'conf|c=s', 'rules=s', 'verbose|v',
	'icmp-types=s{1,}' => \@ICMP_TYPES,
	'failsafe-addr=s{1,}' => \@FAILSAFE_ADDRS,
) or exit(1);

if ($opt{conf}) {
    $CONF = $opt{conf};

# todo: read config file here
}

if ($opt{dir}) {
    $DIR = $opt{dir};
} else {
    ($DIR) = grep { -d $_ } ("/etc/sysconfig/vz-scripts", "/etc/vz/conf");
}

unless ($DIR && -d $DIR) {
	print STDERR qq(
ERROR: vzfirewall could not find openvz container conf files.
(Is openvz installed?)

Use -d to specify their location.

);

	pod2usage( -verbose => 1 );
}

unless ($CONF) {
    ($CONF) = dirname($DIR) . "/vzfirewall.conf";

# todo: re-read config file here
}

my ($RULES_FALLBACK) = dirname($DIR) . "/vzfirewall.rules";
my $RULES_FALLBACK_USED = 0;
my ($IPTABLES) = grep { -f $_ } (
    "/etc/sysconfig/iptables",  # RHEL systems
    "/etc/iptables/rules.v4",   # iptables-persist
    $RULES_FALLBACK             # vzfirewall fallback
);

unless ($IPTABLES) {
    $IPTABLES = $RULES_FALLBACK;
    $RULES_FALLBACK_USED = 1;
}

if ($opt{help}) {
    pod2usage( -verbose => $opt{verbose} ? 2 : 1 );
}
if ($opt{version}) {
    print "vzfirewall $VERSION\n"; exit(0)
}

if ($opt{rules}) {
    $IPTABLES = $opt{rules};
    $RULES_FALLBACK_USED = 0;
}

@ICMP_TYPES = split(" ", join(' ', @ICMP_TYPES));
unless ($ICMP_TYPES[0]) {
    @ICMP_TYPES = (3, 4, 11, 12, 8,);
}

@FAILSAFE_ADDRS = split(" ", join(' ', @FAILSAFE_ADDRS));
unless ($FAILSAFE_ADDRS[0]) {
    @FAILSAFE_ADDRS = "any";
}

if ($RULES_FALLBACK_USED && $opt{verbose}) {
    print STDERR qq(
NOTICE:  vzfirewall did not find any persistent iptables rules locations.
vzfirewall will write iptables rules to:  $RULES_FALLBACK

You will need to arrange for those rules to be loaded at system boot time,
eg. by adding this command to system startup scripts:

        iptables-restore < $RULES_FALLBACK

Or you may find a package such as iptables-persistent for your OS to handle
this for you.

);
}

if ($opt{test}) {
    do_apply(1);
} elsif ($opt{apply}) {
    do_apply(0, defined $opt{force});
} else {
    pod2usage( -verbose => 1 );
}

sub do_apply {
	my ($test_mode, $force) = @_;
	
	my @cmds = ();
	push @cmds, "##\n## PLEASE DO NOT EDIT THIS FILE MANUALLY!!!\n##\n";
	push @cmds, "## It is generated by " . basename($0) . "\n";
	push @cmds, "## All changes will be lost on re-generation!\n##\n";
	push @cmds, "*filter\n";
	push @cmds, ":INPUT ACCEPT [0:0]\n"; # MUST be ACCEPT by default for safety (see footer)
	push @cmds, ":FORWARD ACCEPT [0:0]\n";
	push @cmds, ":OUTPUT ACCEPT [0:0]\n";
	push @cmds, "\n\n";
	push @cmds, "##\n## Basic logging rules with policy actions\n##\n";
	push @cmds, ":vzfw-log-allow - [0:0]\n";
	push @cmds, ":vzfw-log-deny - [0:0]\n";
	push @cmds, "# logging with RETURN policy\n";
	push @cmds, "-A vzfw-log-allow -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix \"[VZFW ALLOW] \"\n";
	push @cmds, "# logging with DENY policy\n";
	push @cmds, "-A vzfw-log-deny -m state --state INVALID -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix \"[VZFW BLOCK] \"\n";
	push @cmds, "-A vzfw-log-deny -m state --state INVALID -j DROP\n";
	push @cmds, "-A vzfw-log-deny -m addrtype --dst-type MULTICAST -j DROP\n";
	push @cmds, "-A vzfw-log-deny -m addrtype --dst-type BROADCAST -j DROP\n";
	push @cmds, "-A vzfw-log-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix \"[VZFW BLOCK] \"\n";
	push @cmds, "-A vzfw-log-deny -j REJECT --reject-with icmp-admin-prohibited\n";
	push @cmds, "\n\n";
	push @cmds, "##\n## Default opened on loopback interface.\n##\n";
	push @cmds, "-A INPUT -i lo -j ACCEPT\n";
	push @cmds, "-A OUTPUT -o lo -j ACCEPT\n";
	push @cmds, "-A FORWARD -i lo -j ACCEPT\n";
	push @cmds, "\n##\n## Stop spoofing of our addresses.\n##\n";
	push @cmds, "-A INPUT -m addrtype --src-type LOCAL -j vzfw-log-deny\n";
	for my $chain ("INPUT", "OUTPUT", "FORWARD") {
		push @cmds, "\n##\n## Firewall states ($chain).\n##\n";
		push @cmds, "-A $chain -m state --state INVALID -j vzfw-log-deny\n";
		push @cmds, "-A $chain -m state --state ESTABLISHED,RELATED -j ACCEPT\n";

		push @cmds, "# Allowed icmp types\n";
		for my $type (@ICMP_TYPES) {
			push @cmds, "-A $chain -p icmp --icmp-type $type -j ACCEPT\n";
		}
	}
	if ( grep { /any/i } @FAILSAFE_ADDRS ) {
		push @cmds, "\n# Failsafe SSH access to hardware node.\n";
		push @cmds, "-A INPUT -p tcp --dport 22 -j vzfw-log-allow\n";
		push @cmds, "-A INPUT -p tcp --dport 22 -j ACCEPT\n";
	} elsif ( grep { /none/i } @FAILSAFE_ADDRS ) {
		push @cmds, "\n# Failsafe SSH access to hardware node is disabled.\n";
	} else {
		push @cmds, "\n# Failsafe SSH access to hardware node.\n";
		for my $addr (@FAILSAFE_ADDRS) {
			push @cmds, "-A INPUT -p tcp -s $addr --dport 22 -j vzfw-log-allow\n";
			push @cmds, "-A INPUT -p tcp -s $addr --dport 22 -j ACCEPT\n";
		}
	}
	push @cmds, "\n\n";
	
	# Collect all data.
	my @parsed = ();
	foreach my $conf (glob($DIR . "/*.conf")) {
		my $basename = basename($conf);
		my $opts = read_conf($conf);
		my ($rules, $custom) = read_rules($opts->{FIREWALL});
		my @dst_ips;
		if ($basename ne "0.conf") {
			my $ips = $opts->{IP_ADDRESS} or die "Cannot find IP_ADDRESS in $conf\n";
			$ips =~ s/^\s+|\s+$//sg;
			@dst_ips = split /\s+/, $ips;
		} else {
			# "" meands "host node IPs" (everything)
			@dst_ips = ("");
		}
		push @parsed, [ $basename, \@dst_ips, $rules, $custom ];
	}
	
	# Generate OPEN commands.
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		next if !@$rules && !@$custom;
		push @cmds, "##\n## Rules from $basename\n##\n";
		foreach my $dst_ip (@$dst_ips) {
			foreach my $pair (@$rules) {
				push @cmds, generate_open_rule(
					$pair->[1], # src ip
					$dst_ip,    # dst ip
					$pair->[0], # dst port(s)
					$pair->[2], # comment
				);
			}
			my @ccmds = ();
			foreach my $rule_c (@$custom) {
				my $rule = $rule_c;
				$rule =~ s/\$THIS/$dst_ip/sg or next;
				die "You cannot use \$THIS in $basename: it is for VEs only\n" if !$dst_ip;
				push @ccmds, $rule . "\n";
			}
			if (@ccmds) {
				push @cmds, "# CUSTOM for $dst_ip ($basename):\n";
				push @cmds, @ccmds;
				push @cmds, "\n";
			}
		}
		my @ccmds = ();
		foreach my $rule (@$custom) {
			next if $rule =~ /\$THIS/s;
			push @ccmds, $rule . "\n";
		}
		if (@ccmds) {
			push @cmds, "# CUSTOM for VE $basename:\n";
			push @cmds, @ccmds;
		}
		push @cmds, "\n\n";
	}
	
	# Generate CLOSE rules for all destination IPs.
	push @cmds, "##\n## All other access to these IPs is closed.\n##\n";
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		push @cmds, map { generate_close_rule($_) } @$dst_ips;
	}

	# Generate OPEN rules for outgoing connections.
	push @cmds, "\n\n##\n## Outgoing connections are permitted.\n##\n";
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		push @cmds, map { generate_outgoing_rule($_) } @$dst_ips;
	}

	push @cmds, "\n\n##\n## Default action for incoming packets - reject.\n##\n";
	push @cmds, "-A INPUT -j vzfw-log-deny\n";
	push @cmds, "-A FORWARD -j vzfw-log-deny\n";
	push @cmds, "COMMIT\n";
	my $cmds = join "", @cmds;
	
	my $prev = "";
	open(local *F, ">>", $IPTABLES) and close(F);
	if (open(local *F, $IPTABLES)) {
		local $/;
		$prev = <F>;
		close(F);
	}

	if ($prev ne $cmds) {
		print STDERR "--DIFF--\n";
		open(local *P, "| diff $IPTABLES - >&2");
		print P $cmds;
		close(P);
		print STDERR "--RULES--\n" if $test_mode;
	}
	
	if ($test_mode) {
		print $cmds;
	} else {
		if ($force || $prev ne $cmds) {
			print STDERR "Testing new rules...\n";
			open(local *P, "| iptables-restore -t");
			print P $cmds;
			if (!close(P)) {
				die "Test failed. Apply nothing.\n";
			}
			# Use cp instead of mv, because this file could be a symlink!
			system("/bin/cp", $IPTABLES, $IPTABLES . ".bak." . strftime("%Y-%m-%d_%H-%M-%S", localtime(time)));
			open(local *F, ">", $IPTABLES) or die "Cannot create $IPTABLES: $!\n";
			print F $cmds;
			close(F);
			print STDERR "Applying new rules...\n";
			system("iptables-restore < $IPTABLES");
		} else {
			die "Nothing is changed.\n";
		}
	}
}

sub read_rules {
	my ($text) = @_;
	return ([], []) if !$text;
	#return ([[ "*", "*", "ANYTHING" ]], []) if !$text;
	my @rules = ();
	my @custom = ();
	my $port = "*";
	foreach (split /\n/, $text) {
		s/^\s+|[#;].*|\s+$//sg;
		next if !$_;
		if (/^\s*\[(.*)\]\s*$/s) {
			$port = $1;
			$port =~ s/\s+//sg;
			next;
		}
		if (lc $port eq "custom") {
			push @custom, $_;
			next;
		}
		my $ips = resolve($_);
		foreach my $ip (@$ips) {
			push @rules, [ $port, $ip, $_ ];
		}
	}
	return (\@rules, \@custom);
}

sub generate_open_rule {
	my ($src_ip, $dst_ip, $dst_port, $comment) = @_;
	my @lines = ("# $comment -> $dst_ip:$dst_port\n");
	my $proto = "tcp";
	if ($dst_port =~ /^([a-z]+):(.*)$/is) {
		$proto = $1;
		$dst_port = $2;
	}
	my $rule =
		($src_ip && $src_ip ne "*"? " -s $src_ip" : "") . 
		($dst_ip && $dst_ip ne "*"? " -d $dst_ip" : "") . 
		($dst_port ne "*"? " -m multiport -p $proto --dports $dst_port" : "") .
		" -j ACCEPT";
	$rule =~ s/\s+/ /sg;
	my $chain = $dst_ip? "FORWARD" : "INPUT";
	push @lines, "-A $chain" . $rule . "\n";
	return join "", @lines;
}

sub generate_close_rule {
	my ($dst_ip) = @_;
	return ($dst_ip && $dst_ip ne "*"? "-A FORWARD -d $dst_ip" : "-A INPUT") . " -j vzfw-log-deny\n";
}

sub generate_outgoing_rule {
	my ($src_ip) = @_;
	return ($src_ip && $src_ip ne "*"? "-A FORWARD -s $src_ip" : "-A OUTPUT") . " -j ACCEPT\n";
}

sub read_conf {
	my ($conf) = @_;
	open(local *F, $conf) or die "Cannot open $conf: $!\n";
	local $/;
	$_ = <F>;
	close(F);
	my %opts = ();
	my @matches = m/^([#](?=FIREWALL))? (\w+) \s* = \s* " ([^\"]*) "/mxg;
	for (my $i = 0; $i < @matches; $i += 3) {
		my $data = $matches[$i + 2];
		$data =~ s/^#//mg if $matches[$i];
		$data =~ s/'/"/sg;
		$opts{$matches[$i + 1]} = $data;
	}
	return \%opts;
}

my %resolved = ();
sub resolve {
	my ($host) = @_;
	return [ $host ] if $host =~ /^\d+\.\d+\.\d+\.\d+|^\*$/s;
	return $resolved{$host} if $resolved{$host};
	my @ips = (`host $host.`||"") =~ /(\d+\.\d+\.\d+\.\d+$)/mg or die "Cannot resolve $host\n";
	foreach (@ips) {
		die "Invalid address $_ resolved for $host\n" if /^(128|255)/s;
	}
	return $resolved{$host} = \@ips;
}


__END__

=head1 NAME

vzfirewall - A simple firewall for OpenVZ

=head1 SYNOPSIS

B<vzfirewall> (B<-h>|B<-V>|B<-a>|B<-t>) [B<option> ...]

You B<must> specify an action with one of the following:

=over 20

=item B<-h>, B<--help>

Display this help and exit.

=item B<-V>, B<--version>

Output vzfirewall version and exit.

=item B<-a>, B<--apply>

Apply iptables rules in $DIR/*.conf (FIREWALL directives).

=item B<-t>, B<--test>

Preview iptables rules in $DIR/*.conf without activation.

=back

You B<may> specify any of the options:

=over 20

=item B<-f>, B<--force>

Force iptables rules rewrite even if rules are unchanged.

=item B<-c>, B<--conf>=I<PATH>

Location of vzfirewall configuration file.

=item B<-d>, B<--dir>=I<PATH>

Specify directory containing per-container .conf files.

=item B<--rules>=I<PATH>

Store iptables rules in this file.

=item B<-v>, B<--verbose>

Be more verbose.

=back

You can change the default firewall behavior with the following options:

=over 20

=item B<--icmp-types>=I<types>

Specify allowed icmp types.

Default: 3 4 11 12 8 (destination-unreachable source-quench time-exceeded parameter-problem echo-request)

=item B<--failsafe-addr>=I<addr>

Specify hosts allowed administrative (ssh) access to the openvz hardware node.
I<addr> can be a single host, subnet, C<any> or C<none>.

Default: any

=back


=head1 DESCRIPTION

vzfirewall is a simple firewall for an openvz host
which protects both the openvz host and its containers.

vzfirewall uses openvz container .conf files for configuration,
just add a C<FIREWALL> directive to specify the firewall rules.

=head1 EXAMPLES

=head2 Firewall the OpenVZ host

A C<FIREWALL> directive in I<0.conf> specifies firewall rules
for the openvz host.  Add something like this to I</etc/vz/conf/0.conf>:

 #FIREWALL="
 #   # allow all access from the administrator's workstation
 #   admin.domain.com
 #
 #   # allow our OpenVZ Web Panel to talk to the owp hardware daemon
 #   [7767]
 #   owp.domain.com
 #
 #   # we run an ntp server on the openvz host
 #   [udp:123]
 #   *
 #"

Run C<vzfirewall -t> to test the configuration.
When it looks good, apply the new rules:  C<vzfirewall -a>.

Note the C<#> prefix character for the entire C<FIREWALL> directive
is intentional, other OpenVZ utilities issue warnings if left out.


=head2 Firewall a container

Say you have a container with C<CTID> I<123> running a web server.
(Use C<vzlist> to determine the container id.)  Add the following to 
I</etc/vz/conf/123.conf>:

 #FIREWALL="
 #   [80,443]
 #   *
 #"

Run C<vzfirewall -a> to apply the new rules.


=head1 FILES

=over

=item C</etc/vz/vzfirewall.conf>, C</etc/sysconfig/vzfirewall.conf>

Default vzfirewall configuration file locations.

=item C</etc/vz/conf/*.conf>, C</etc/sysconfig/vz-scripts/*.conf>

Default location of OpenVZ container .conf scripts.

=item C</etc/sysconfig/iptables>, C</etc/iptables/rules.v4>, C</etc/vz/vzfirewall.rules>

Default locations searched for stored iptables rules file.

=back

=head1 SEE ALSO

=over

=item L<iptables(8)>

administration tool for IPv4 packet filtering and NAT

=item L<ctid.conf(5)>

configuration file for an OpenVZ container

=item L<http://en.dklab.ru/lib/dklab_vzfirewall>

vzfirewall homepage

=item L<https://github.com/DmitryKoterov/vzfirewall>

Development and Latest Version

=back

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; either version 2.1 of the License,
or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to:

=over 4

 The Free Software Foundation, Inc.
 51 Franklin Street
 Fifth Floor
 Boston, MA 02110-1301 USA

=back

=head1 AUTHORS

=over

=item Dmitry Koterov <dmitry.koterov@gmail.com>

=item Jesse Norell <jesse@kci.net>

=back

=cut

