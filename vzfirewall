#!/usr/bin/perl -w
#
# vzfirewall:  A simple firewall for OpenVZ
#
# See 'vzfirewall -h' for documentaion.
#
# Check https://github.com/DmitryKoterov/vzfirewall
# for latest version and development info.

use strict;
use Pod::Usage;
use File::Basename;
use POSIX 'strftime';
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);

my $VERSION = "1.09, 2014-01-07";
my ($DIR) = grep { -d $_ } ("/etc/sysconfig/vz-scripts", "/etc/vz/conf");

unless ($DIR && -d $DIR) {
	print STDERR "$0: Error: Could not find openvz container conf files.\n"
	. "(Is openvz installed?)\n\n"
	. "Use -d to specify their location.\n\n";

	pod2usage( -verbose => 1 );
}

my ($CONF) = dirname($DIR) . "/vzfirewall.conf";
my ($RULES) = dirname($DIR) . "/vzfirewall.rules";
my ($IPTABLES) = grep { -f $_ } ($RULES, "/etc/sysconfig/iptables", "/etc/iptables/rules.v4");
($IPTABLES) or $IPTABLES = $RULES;

my %opt = ();
GetOptions(\%opt, 'help|h', 'version|V', 'apply|a', 'test|t',
	'force|f', 'dir|d=s', 'conf|c=s', 'rules=s', 'verbose|v',
) or exit(1);

if ($opt{help}) {
        pod2usage( -verbose => $opt{verbose} ? 2 : 1 );
}
if ($opt{version}) {
        print "vzfirewall $VERSION\n"; exit(0)
}
if ($opt{conf}) {
        $CONF = $opt{conf};
}

# todo: read config file here

if ($opt{rules}) {
    $IPTABLES = $opt{rules};
}
if ($opt{dir}) {
    $DIR = $opt{dir};
}

if ($opt{test}) {
    do_apply(1);
} elsif ($opt{apply}) {
    do_apply(0, defined $opt{force});
} else {
    pod2usage( -verbose => 1 );
}

sub do_apply {
	my ($test_mode, $force) = @_;
	
	my @cmds = ();
	push @cmds, "##\n## PLEASE DO NOT EDIT THIS FILE MANUALLY!!!\n##\n";
	push @cmds, "## It is generated by " . basename($0) . "\n";
	push @cmds, "## All changes will be lost on re-generation!\n##\n";
	push @cmds, "*filter\n";
	push @cmds, ":INPUT ACCEPT [0:0]\n"; # MUST be ACCEPT by default for safety (see footer)
	push @cmds, ":FORWARD ACCEPT [0:0]\n";
	push @cmds, ":OUTPUT ACCEPT [0:0]\n";
	push @cmds, "\n\n";
	push @cmds, "##\n## Default opened channels.\n##\n";
	push @cmds, "-A INPUT -i lo -j ACCEPT\n";
	push @cmds, "-A OUTPUT -o lo -j ACCEPT\n";
	push @cmds, "-A FORWARD -i lo -j ACCEPT\n";
	for ("INPUT", "OUTPUT", "FORWARD") {
		push @cmds, "-A $_ -p icmp -j ACCEPT\n";
		push @cmds, "-A $_ -m state --state ESTABLISHED,RELATED -j ACCEPT\n";
	}
	push @cmds, "# Open SSH port on hardware node - for safety.\n";
	push @cmds, "-A INPUT -p tcp --dport 22 -j ACCEPT\n";
	push @cmds, "\n\n";
	
	# Collect all data.
	my @parsed = ();
	foreach my $conf (glob($DIR . "/*.conf")) {
		my $basename = basename($conf);
		my $opts = read_conf($conf);
		my ($rules, $custom) = read_rules($opts->{FIREWALL});
		my @dst_ips;
		if ($basename ne "0.conf") {
			my $ips = $opts->{IP_ADDRESS} or die "Cannot find IP_ADDRESS in $conf\n";
			$ips =~ s/^\s+|\s+$//sg;
			@dst_ips = split /\s+/, $ips;
		} else {
			# "" meands "host node IPs" (everything)
			@dst_ips = ("");
		}
		push @parsed, [ $basename, \@dst_ips, $rules, $custom ];
	}
	
	# Generate OPEN commands.
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		next if !@$rules && !@$custom;
		push @cmds, "##\n## Rules from $basename\n##\n";
		foreach my $dst_ip (@$dst_ips) {
			foreach my $pair (@$rules) {
				push @cmds, generate_open_rule(
					$pair->[1], # src ip
					$dst_ip,    # dst ip
					$pair->[0], # dst port(s)
					$pair->[2], # comment
				);
			}
			my @ccmds = ();
			foreach my $rule_c (@$custom) {
				my $rule = $rule_c;
				$rule =~ s/\$THIS/$dst_ip/sg or next;
				die "You cannot use \$THIS in $basename: it is for VEs only\n" if !$dst_ip;
				push @ccmds, $rule . "\n";
			}
			if (@ccmds) {
				push @cmds, "# CUSTOM for $dst_ip ($basename):\n";
				push @cmds, @ccmds;
				push @cmds, "\n";
			}
		}
		my @ccmds = ();
		foreach my $rule (@$custom) {
			next if $rule =~ /\$THIS/s;
			push @ccmds, $rule . "\n";
		}
		if (@ccmds) {
			push @cmds, "# CUSTOM for VE $basename:\n";
			push @cmds, @ccmds;
		}
		push @cmds, "\n\n";
	}
	
	# Generate CLOSE rules for all destination IPs.
	push @cmds, "##\n## All other access to these IPs is closed.\n##\n";
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		push @cmds, map { generate_close_rule($_) } @$dst_ips;
	}

	# Generate OPEN rules for outgoing connections.
	push @cmds, "\n\n##\n## Outgoing connections are permitted.\n##\n";
	foreach (@parsed) {
		my ($basename, $dst_ips, $rules, $custom) = @$_;
		push @cmds, map { generate_outgoing_rule($_) } @$dst_ips;
	}

	push @cmds, "\n\n##\n## Default action for incoming packets - reject.\n##\n";
	push @cmds, "-A INPUT -j DROP\n";
	push @cmds, "-A FORWARD -j DROP\n";
	push @cmds, "COMMIT\n";
	my $cmds = join "", @cmds;
	
	my $prev = "";
	open(local *F, ">>", $IPTABLES) and close(F);
	if (open(local *F, $IPTABLES)) {
		local $/;
		$prev = <F>;
		close(F);
	}

	if ($prev ne $cmds) {
		print STDERR "--DIFF--\n";
		open(local *P, "| diff $IPTABLES - >&2");
		print P $cmds;
		close(P);
		print STDERR "--RULES--\n" if $test_mode;
	}
	
	if ($test_mode) {
		print $cmds;
	} else {
		if ($force || $prev ne $cmds) {
			print STDERR "Testing new rules...\n";
			open(local *P, "| iptables-restore -t");
			print P $cmds;
			if (!close(P)) {
				die "Test failed. Apply nothing.\n";
			}
			# Use cp instead of mv, because this file could be a symlink!
			system("/bin/cp", $IPTABLES, $IPTABLES . ".bak." . strftime("%Y-%m-%d_%H-%M-%S", localtime(time)));
			open(local *F, ">", $IPTABLES) or die "Cannot create $IPTABLES: $!\n";
			print F $cmds;
			close(F);
			print STDERR "Applying new rules...\n";
			system("iptables-restore < $IPTABLES");
		} else {
			die "Nothing is changed.\n";
		}
	}
}

sub read_rules {
	my ($text) = @_;
	return ([], []) if !$text;
	#return ([[ "*", "*", "ANYTHING" ]], []) if !$text;
	my @rules = ();
	my @custom = ();
	my $port = "*";
	foreach (split /\n/, $text) {
		s/^\s+|[#;].*|\s+$//sg;
		next if !$_;
		if (/^\s*\[(.*)\]\s*$/s) {
			$port = $1;
			$port =~ s/\s+//sg;
			next;
		}
		if (lc $port eq "custom") {
			push @custom, $_;
			next;
		}
		my $ips = resolve($_);
		foreach my $ip (@$ips) {
			push @rules, [ $port, $ip, $_ ];
		}
	}
	return (\@rules, \@custom);
}

sub generate_open_rule {
	my ($src_ip, $dst_ip, $dst_port, $comment) = @_;
	my @lines = ("# $comment -> $dst_ip:$dst_port\n");
	my $proto = "tcp";
	if ($dst_port =~ /^([a-z]+):(.*)$/is) {
		$proto = $1;
		$dst_port = $2;
	}
	my $rule =
		($src_ip && $src_ip ne "*"? " -s $src_ip" : "") . 
		($dst_ip && $dst_ip ne "*"? " -d $dst_ip" : "") . 
		($dst_port ne "*"? " -m multiport -p $proto --dports $dst_port" : "") .
		" -j ACCEPT";
	$rule =~ s/\s+/ /sg;
	my $chain = $dst_ip? "FORWARD" : "INPUT";
	push @lines, "-A $chain" . $rule . "\n";
	return join "", @lines;
}

sub generate_close_rule {
	my ($dst_ip) = @_;
	return ($dst_ip && $dst_ip ne "*"? "-A FORWARD -d $dst_ip" : "-A INPUT") . " -j DROP\n";
}

sub generate_outgoing_rule {
	my ($src_ip) = @_;
	return ($src_ip && $src_ip ne "*"? "-A FORWARD -s $src_ip" : "-A OUTPUT") . " -j ACCEPT\n";
}

sub read_conf {
	my ($conf) = @_;
	open(local *F, $conf) or die "Cannot open $conf: $!\n";
	local $/;
	$_ = <F>;
	close(F);
	my %opts = ();
	my @matches = m/^([#](?=FIREWALL))? (\w+) \s* = \s* " ([^\"]*) "/mxg;
	for (my $i = 0; $i < @matches; $i += 3) {
		my $data = $matches[$i + 2];
		$data =~ s/^#//mg if $matches[$i];
		$opts{$matches[$i + 1]} = $data;
	}
	return \%opts;
}

my %resolved = ();
sub resolve {
	my ($host) = @_;
	return [ $host ] if $host =~ /^\d+\.\d+\.\d+\.\d+|^\*$/s;
	return $resolved{$host} if $resolved{$host};
	my @ips = (`host $host.`||"") =~ /(\d+\.\d+\.\d+\.\d+$)/mg or die "Cannot resolve $host\n";
	foreach (@ips) {
		die "Invalid address $_ resolved for $host\n" if /^(128|255)/s;
	}
	return $resolved{$host} = \@ips;
}


__END__

=head1 NAME

vzfirewall - A simple firewall for OpenVZ

=head1 SYNOPSIS

B<vzfirewall> (B<-h>|B<-V>|B<-a>|B<-t>) [B<option> ...]

You B<must> specify an action with one of the following:

=over 20

=item B<-h>, B<--help>

Display this help and exit.

=item B<-V>, B<--version>

Output vzfirewall version and exit.

=item B<-a>, B<--apply>

Apply iptables rules in $DIR/*.conf (FIREWALL directives).

=item B<-t>, B<--test>

Preview iptables rules in $DIR/*.conf without activation.

=back

You B<may> specify any of the options:

=over 20

=item B<-f>, B<--force>

Force iptables rules rewrite even if rules are unchanged.

=item B<-c>, B<--conf>=I<PATH>

Location of vzfirewall configuration file.

=item B<-d>, B<--dir>=I<PATH>

Specify directory containing per-container .conf files.

=item B<--rules>=I<PATH>

Store iptables rules in this file.

=item B<-v>, B<--verbose>

Be more verbose.

=back


=head1 DESCRIPTION

vzfirewall is a simple firewall for an openvz host
which protects both the openvz host and its containers.

vzfirewall uses openvz container .conf files for configuration,
just add a C<FIREWALL> directive to specify the firewall rules.

=head1 EXAMPLES

=head2 Firewall the OpenVZ host

A C<FIREWALL> directive in I<0.conf> specifies firewall rules
for the openvz host.  Add something like this to I</etc/vz/conf/0.conf>:

 #FIREWALL="
 #   # allow all access from the administrator's workstation
 #   admin.domain.com
 #
 #   # allow our OpenVZ Web Panel to talk to the owp hardware daemon
 #   [7767]
 #   owp.domain.com
 #
 #   # we run an ntp server on the openvz host
 #   [udp:123]
 #   *
 #"

Run C<vzfirewall -t> to test the configuration.
When it looks good, apply the new rules:  C<vzfirewall -a>.

Note the C<#> prefix character for the entire C<FIREWALL> directive
is intentional, other OpenVZ utilities issue warnings if left out.


=head2 Firewall a container

Say you have a container with C<CTID> I<123> running a web server.
(Use C<vzlist> to determine the container id.)  Add the following to 
I</etc/vz/conf/123.conf>:

 #FIREWALL="
 #   [80,443]
 #   *
 #"

Run C<vzfirewall -a> to apply the new rules.


=head1 FILES

=over

=item C</etc/vz/vzfirewall.conf>, C</etc/sysconfig/vzfirewall.conf>

Default vzfirewall configuration file locations.

=item C</etc/vz/conf/*.conf>, C</etc/sysconfig/vz-scripts/*.conf>

Default location of OpenVZ container .conf scripts.

=item C</etc/vz/vzfirewall.rules>, C</etc/sysconfig/iptables>, C</etc/iptables/rules.v4>

Default location of stored iptables rules file.

=back

=head1 SEE ALSO

=over

=item L<iptables(8)>

administration tool for IPv4 packet filtering and NAT

=item L<ctid.conf(5)>

configuration file for an OpenVZ container

=item L<http://en.dklab.ru/lib/dklab_vzfirewall>

vzfirewall homepage

=item L<https://github.com/DmitryKoterov/vzfirewall>

Development and Latest Version

=back

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; either version 2.1 of the License,
or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to:

=over 4

 The Free Software Foundation, Inc.
 51 Franklin Street
 Fifth Floor
 Boston, MA 02110-1301 USA

=back

=head1 AUTHORS

=over

=item Dmitry Koterov <dmitry.koterov@gmail.com>

=item Jesse Norell <jesse@kci.net>

=back

=cut

